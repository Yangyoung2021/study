# 存储引擎、索引

## 1、存储引擎在MySQL的位置

<font color='red' size='5'>MySQL主要分为四层结构</font>（索引处在第三层，所以不同的存储引擎的索引不同）

* 第一层（网络连接层）
  主要用来数据库的连接、权限认证校验的功能

* 第二层（服务层）

  负责核心功能的处理，包括SQL的解析、SQL优化、缓存等方面

* 第三层（存储引擎）

  MySQL中用来决定数据存放的具体方式

* 第四层（数据存储层）
  用于将数据放在运行的文件系统中

![图片](https://images-roland.oss-cn-shenzhen.aliyuncs.com/blog/mysql/202208061121197.png)

## 2、常见的存储引擎

### 2.1 InnoDB

* 从MySQL5.5版本开始，成为了其默认的存储引擎，具有最重要的三大特性是<font color=red size=4>DML支持ACID事务、外键、行锁</font>。

### 2.2 MyISAM

* MySQL5.5之前版本的默认存储引擎，不支持事务和外键，只支持表锁，并发性能较差，目前被MongoDB代替。

### 2.3 MEMORY

* 利用内存创建表，访问速度非常快，因为数据在内存，而且默认使用Hash索引，所以不能支持范围查询。另外数据库一旦关闭，数据就会丢失，一般用作临时表。目前被Redis代替。

## 3、InnoDB索引

### 3.1 定义及优缺点

* 在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

* 索引最大的优势就是能很大程度上加快查询速度。但是与此同时也让DML语句增加了维护索引的额外消耗，因此建议当数据量比较大（百万）且大部分操作为查询操作时须建立相对应的索引。

### 3.2 InnoDB索引

<font color=red size=5>全文索引</font>

* 倒排索引实现

<font color=red size=5>自适应哈希索引</font>

* 只能等值查询，基于hash实现

<font color=red size=5>B+树索引</font>

* 数据结构
  B+树，只有叶子节点真正存放数据，其他节点都是作为索引存在，存储数据的ROW通过单项链表实现。MySQL额外给叶子节点之间添加了双向链表。用于快速查找数据。

* 分类

  * 聚集索引（聚簇索引、主键索引）

    创建表时自动创建，一个表中有且只有一个，如果表中存在主键，使用主键作为索引，如果没有主键将使用第一个Unique索引作为索引，如果没有Unique索引将会使用行号作为索引，每个表中的数据都是放在了叶子节点中，每个叶子节点都对应一行数据

  * 二级索引
    可以为0个或者多个，每个非叶子节点存储的是创建的索引列的值，叶子节点存储的是聚集索引的索引值，一般为主键值
    * 唯一索引
    * 普通索引
    * 组合索引
      当使用是需要遵守最左前缀原则，即只有查询条件为创建索引的顺序中从最左侧的开始匹配一个或者多个时才能使用该索引。
    * 前缀索引
      当创建索引列的长度比较大时，为了节省空间并达到索引的效果，将使用前几位作为索引。

* 创建索引

  ~~~sql
  -- 创建普通索引
  create index idx_name on tableName(columnName);
  -- 创建唯一索引
  create unique index idx_unique_name on tableName(column);
  -- 创建联合索引
  create index idx_name on tableName(column1, column2);
  -- 使用DML语句创建索引
  ALTER TABLE tb_1 ADD UNIQUE INDEX idx_tb_name (name);
  ~~~

* 删除索引

  ~~~sql
  -- 使用常规方法删除索引
  drop index idx_name from tb_1;
  -- 使用DML语句删除索引
  alter table tb_1 drop index idx_name;
  ~~~

* SQL性能分析工具

  ~~~sql
  -- 查看SQL执行频率
  SHOW GLOBAL STATUS LIKE 'Com_______';
  -- 查看SQL执行计划，在SQL之前添加explain或者desc关键字
  explain select * from user;
  -- 查看SQL执行花费的时间
  show @@profiling; -- 查看是否开启profile
  SET SESSION  profiling = 1; -- 开启session级别的profile
  SHOW profiles; -- 查看具体的SQL执行时间
  ~~~

* 索引失效情况

  1. 使用<font color=red>组合索引</font>没有遵守最左前缀原则

  2. 使用<font color=red>组合索引</font>时进行返回搜索时使用了>或者<符号

  3. 当前查询条件击中多个索引，导致其中先创建的生效，其余的不生效

  4. 当MySQL认为使用全表扫描要快于使用索引时

  5. 当使用or关键子进行搜索时其中一边没有建立索引

  6. 使用like关键字进行左模糊或者全模糊查询

  7. 当对索引列进行了运算操作时

     ~~~sql
     -- 使用substring对id进行运算，虽然结果没有改变，但是还是会导致索引失效
     EXPLAIN SELECT * FROM USER WHERE substring(id, 1, 16) = '2646572806543270';
     ~~~

  8. 解析SQL使用到了MySQL的数字转字符串的内置函数

* SQL性能优化

  1. 主键优化
     主键尽量使用递增的，长度较短的，因为主键如果不是递增的插入新数据时可能会导致<font color=red>页分裂</font>的情况从而降低性能，如果长度太长，其他索引中存储的都是数据都是主键值，就会导致占用内存比较大。

  2. order by优化
     给排序字段创建索引，如果多个字段排序，需要遵守最左前缀法则，最好能创建覆盖索引，减少回表查询的时间。

  3. limit分页优化

     当数据量较大时，limit查询速度十分缓慢，可以使用子查询进行优化，先查找id，然后通过查找id的表格作为子表和原始表格联合查询，注意不能使用in关键字，只能使用where或者join联查。

  4. count优化
     **count函数使用分为4种，count(\*)、count(1)、count(id)、count(列名)**
     1. 如果使用count(列名)，会先判断该列是否可以为空，如果不是一定不为空就会将该列中的数据取出返回给服务层，然后服务层判断是否为空，如果不是为空就将计数值加一，如果该列是非空的，就会将值取出然后进行累加。
     2. 如果使用count(id)，会先将每一行的id值取出返回给服务层，服务层直接进行累加（主键不能为空）。
     3. 如果使用count(1)，不会进行取值，而是以行为单位直接进行累加。
     4. 使用count(\*)也不会进行取值，直接让服务层进行累加，因为MySQL专门对count(\*)进行了优化。
     5. <font color=red>**推荐使用count(1)和count(\*)，减去取值的性能消耗**。</font>
  5. update优化
     由于MySQL5.5之后默认使用InnoDB作为存储引擎，所以默认是开启行锁和自动提交事务的，用于提高并发性，使用update进行操作时，如果是根据非索引字段更新，所以无法快速获取主键值，MySQL不能直接确定当前操作的是哪一行，所以这个时候就会升级为表锁防止其他连接进行修改，如果此时有其他连接进行修改操作的话，就会陷入阻塞。但是如果此时使用的是主键或者其他的有索引的字段作为更新条件，就能迅速确定当前操作的是哪一行，只会对改行进行加行锁，其他非操作该行的就不用阻塞。所以进行<Font color=red>**update更新时需要选择有索引的字段为条件进行更新**。</font>